#![feature(allocator_api)]

pub mod constraints;

use ark_ff_optimized::fp64::Fp;
use constraints::Constraint;
use fast_poly::allocator::PageAlignedAllocator;
use fast_poly::GpuField;

/// Matrix is an array of columns.
pub struct Matrix<F>(Vec<Vec<F, PageAlignedAllocator>>);

impl<F: GpuField> Matrix<F> {
    fn num_rows(&self) -> usize {
        if self.0.is_empty() {
            return 0;
        }
        // Check all columns have the same length
        let expected_len = self.0[0].len();
        assert!(self.0.iter().all(|col| col.len() == expected_len));
        expected_len
    }

    fn num_cols(&self) -> usize {
        self.0.len()
    }

    fn is_empty(&self) -> bool {
        self.num_rows() == 0
    }
}

pub trait Trace {
    type BaseField: GpuField;

    /// Returns the number of rows in this trace.
    fn len(&self) -> usize;

    fn is_empty(&self) -> bool {
        self.len() == 0
    }

    /// Returns a reference to the base trace columns.
    fn base_columns(&self) -> &Matrix<Self::BaseField>;

    /// Builds and returns the extension columns
    /// These columns require auxiliary random elements to be constructed.
    /// Returns None if there are no columns that require this.
    fn build_extension_columns(
        &self,
        challenges: &[Self::BaseField],
    ) -> Option<Matrix<Self::BaseField>>;
}

// TODO: include ability to specify:
// - base field
// - extension field
// - hashing function
// - determine if grinding factor is appropriate
// - fri folding factor
// - fri max remainder size
pub struct ProofOptions {
    pub num_queries: u8,
    pub expansion_factor: u8,
}

impl ProofOptions {
    pub fn new(num_queries: u8, expansion_factor: u8) -> Self {
        ProofOptions {
            num_queries,
            expansion_factor,
        }
    }
}

/// A proof generated by a mini-stark prover
pub struct Proof {
    /// Parameters for the proof
    options: ProofOptions,
    /// Merkle commitments made during the proving
    commitments: Vec<u64>,
    /// Length of the execution trace
    trace_len: usize,
}

pub trait Air {
    type BaseField: GpuField;

    fn new(trace_len: usize, options: ProofOptions) -> Self;

    fn boundary_constraints() -> Vec<Constraint<Self::BaseField>>;

    fn transition_constraints() -> Vec<Constraint<Self::BaseField>>;

    fn terminal_constraints() -> Vec<Constraint<Self::BaseField>>;
}

/// Errors that can occur during the proving stage
pub enum ProvingError {
    // /// This error occurs when a transition constraint evaluated over a specific execution trace
    // /// does not evaluate to zero at any of the steps.
    // UnsatisfiedTransitionConstraintError(usize),
    // /// This error occurs when polynomials built from the columns of a constraint evaluation
    // /// table do not all have the same degree.
    // MismatchedConstraintPolynomialDegree(usize, usize),
}

pub trait Prover {
    type BaseField: GpuField;
    type Air: Air<BaseField = Self::BaseField>;
    type Trace: Trace<BaseField = Self::BaseField>;

    fn new(options: ProofOptions) -> Self;

    fn options(&self) -> ProofOptions;

    fn generate_proof(&self, trace: Self::Trace) -> Result<Proof, ProvingError> {
        let options = self.options();

        Ok(Proof {
            options,
            commitments: Vec::new(),
            trace_len: trace.len(),
        })
    }
}
